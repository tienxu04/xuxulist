<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Danh sách review — @xuxudocsach</title>
  <style>
    /* ...[CSS unchanged, see previous version for details]... */
    /* For brevity, CSS is omitted here as your request is about logic changes. */
  </style>
</head>
<body>
<div class="wrap">
  <h1>Danh sách review — @xuxudocsach</h1>
  <div class="small">Các bạn có thể sort theo header, hoặc tìm theo tựa / tác giả / thể loại / quốc gia trong thanh tìm kiếm bên dưới</div>
  <div class="toolbar">
    <input id="q" size="28" autocomplete="off" type="search" placeholder="Gõ tựa/tác giả/thể loại/quốc gia" />
    <span class="count" id="count"></span>
  </div>
  <div class="sortgroup">
    <select id="sortBy" aria-label="Sắp xếp theo">
      <option value="title">Tựa</option>
      <option value="genre">Thể loại</option>
      <option value="author">Tác giả</option>
      <option value="country">Quốc gia</option>
    </select>
    <button id="sortDir" class="btn tonal" type="button" aria-label="Đổi thứ tự">
      ↑ A–Z
    </button>
  </div>
  <table id="table">
    <thead>
      <tr>
        <th data-key="title">Tựa</th>
        <th data-key="genre">Thể loại</th>
        <th data-key="author">Tác giả</th>
        <th data-key="country">Quốc gia</th>
        <th data-key="review">xuxu review</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTTl4QUkDw2-np7Nc8jxJcbtXeDuFDnnXV85ClQENI-uR9UBicTGyD76rgnUlv-kCH8n5xBR49-92ky/pub?output=csv";
const headerMap = {
  "title": "Tựa",
  "genre": "Thể loại",
  "author": "Tác giả",
  "country": "Quốc gia",
  "review": "xuxu review"
};
const diacriticless = s => (s||"").toString().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

function parseCSV(text) {
  const rows = [], cur = [];
  let i = 0, cell = '', inQuotes = false;
  const pushCell = () => { cur.push(cell); cell = '' };
  const pushRow = () => { rows.push(cur.slice()); cur.length = 0 };
  while (i < text.length) {
    const c = text[i];
    if (inQuotes) {
      if (c === '"') {
        if (text[i+1] === '"') { cell += '"'; i++; }
        else { inQuotes = false; }
      } else { cell += c; }
    } else {
      if (c === '"') inQuotes = true;
      else if (c === ',') pushCell();
      else if (c === '\r') {}
      else if (c === '\n') { pushCell(); pushRow(); }
      else cell += c;
    }
    i++;
  }
  if (cell.length || cur.length) { pushCell(); pushRow(); }
  return rows;
}

function rowsToObjects(rows) {
  if (!rows.length) return [];
  const header = rows[0].map(h => h.trim());
  return rows.slice(1).map(r => {
    const obj = {};
    header.forEach((h, idx) => obj[h] = (r[idx] ?? "").trim());
    return obj;
  });
}

function mapRecord(rec) {
  const out = {};
  for (const key in headerMap) out[key] = rec[headerMap[key]] ?? "";
  return out;
}

function linkify(text) {
  if (!text) return "";
  const urlRegex = /(https?:\/\/[^\s)]+)|(www\.[^\s)]+)/gi;
  return text.replace(urlRegex, m => {
    const url = m.startsWith('http') ? m : 'http://' + m;
    return `<a href="${url}" target="_blank" rel="noopener">${m}</a>`;
  });
}

let data = [], filtered = [];
let sortState = { key: null, dir: "asc" }; // default: no sort

const tbody = document.querySelector("#table tbody");
const countEl = document.getElementById("count");
const sortByEl = document.getElementById("sortBy");
const sortDirEl = document.getElementById("sortDir");

function render() {
  tbody.innerHTML = "";
  filtered.forEach(row => {
    const tr = document.createElement("tr");
    // Tựa
    const tdTitle = document.createElement("td");
    tdTitle.textContent = row.title || "(Không tiêu đề)";
    tdTitle.dataset.label = "Tựa";
    tr.appendChild(tdTitle);
    // Thể loại
    const tdGenre = document.createElement("td");
    tdGenre.textContent = row.genre || "";
    tdGenre.dataset.label = "Thể loại";
    tr.appendChild(tdGenre);
    // Tác giả
    const tdAuthor = document.createElement("td");
    tdAuthor.textContent = row.author || "";
    tdAuthor.dataset.label = "Tác giả";
    tr.appendChild(tdAuthor);
    // Quốc gia
    const tdCountry = document.createElement("td");
    tdCountry.textContent = row.country || "";
    tdCountry.dataset.label = "Quốc gia";
    tr.appendChild(tdCountry);
    // xuxu review
    const tdReview = document.createElement("td");
    tdReview.innerHTML = row.review ? linkify(row.review) : '<span class="muted">—</span>';
    tdReview.dataset.label = "xuxu review";
    tr.appendChild(tdReview);

    tbody.appendChild(tr);
  });

  countEl.textContent = `${filtered.length} mục`;

  // Sort indicator
  document.querySelectorAll("th[data-key]").forEach(th => {
    th.setAttribute("aria-sort", "none");
    const ind = th.querySelector(".sort-ind");
    if (ind) ind.remove();
  });
  if (sortState.key) {
    const thActive = document.querySelector(`th[data-key="${sortState.key}"]`);
    if (thActive) {
      thActive.setAttribute("aria-sort", sortState.dir === "asc" ? "ascending" : "descending");
      const ind = document.createElement("span");
      ind.className = "sort-ind";
      ind.textContent = sortState.dir === "asc" ? "▲" : "▼";
      thActive.appendChild(ind);
    }
  }
  syncSortUI();
}

function applyFilterAndSort() {
  const q = diacriticless(document.getElementById("q").value);
  filtered = data.filter(r => {
    const hay = [r.title, r.author, r.genre, r.country, r.review].map(diacriticless).join(" ");
    return hay.includes(q);
  });

  const { key, dir } = sortState;
  if (key) {
    filtered.sort((a, b) => {
      const va = a[key] ?? "";
      const vb = b[key] ?? "";
      const sa = diacriticless(String(va));
      const sb = diacriticless(String(vb));
      if (sa < sb) return dir === "asc" ? -1 : 1;
      if (sa > sb) return dir === "asc" ? 1 : -1;
      return 0;
    });
  }
  render();
}

function debounce(fn, ms=150){
  let t;
  return (...a)=>{
    clearTimeout(t);
    t = setTimeout(()=>fn(...a), ms);
  }
}

function syncSortUI(){
  if (sortByEl) sortByEl.value = sortState.key || "title"; // fallback for select
  if (sortDirEl) {
    sortDirEl.textContent = (sortState.dir === "asc") ? "↑ A–Z" : "↓ Z–A";
    sortDirEl.setAttribute("aria-label", sortState.dir === "asc" ? "Đổi sang Z–A" : "Đổi sang A–Z");
  }
}

// Event listeners
document.getElementById("q").addEventListener("input", debounce(applyFilterAndSort, 120));
document.querySelectorAll("th[data-key]").forEach(th => {
  th.addEventListener("click", () => {
    const key = th.getAttribute("data-key");
    if (sortState.key === key) sortState.dir = sortState.dir === "asc" ? "desc" : "asc";
    else { sortState.key = key; sortState.dir = "asc"; }
    applyFilterAndSort();
  });
});
if (sortByEl) {
  sortByEl.addEventListener("change", () => {
    sortState.key = sortByEl.value;
    sortState.dir = "asc";
    applyFilterAndSort();
  });
}
if (sortDirEl) {
  sortDirEl.addEventListener("click", () => {
    sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
    applyFilterAndSort();
  });
}

// Initial load
(async function init() {
  try {
    const res = await fetch(CSV_URL);
    if (!res.ok) throw new Error("Không tải được CSV. Kiểm tra quyền Publish.");
    const text = await res.text();
    const rows = parseCSV(text);
    const objects = rowsToObjects(rows);
    data = objects.map(mapRecord);
    applyFilterAndSort();
  } catch (e) {
    alert("Lỗi tải dữ liệu: " + e.message);
    console.error(e);
  }
})();
</script>
</body>
</html>
